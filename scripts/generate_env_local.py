#!/usr/bin/env python3
# Copyright (c) 2025 Tyl Consulting di Pancotti Marco
"""Generate .env.local from config.yml.local for local ThothAI development."""

from __future__ import annotations

import argparse
import secrets
import sys
from pathlib import Path
from typing import Dict, Any

try:
    import yaml  # type: ignore
except ModuleNotFoundError as exc:  # pragma: no cover - handled at runtime
    print("Error: PyYAML is required to run this script (pip install pyyaml).", file=sys.stderr)
    raise

CONFIG_PATH = Path("config.yml.local")
ENV_PATH = Path(".env.local")
BACKUP_SUFFIX = ".backup"
HEADER = """# Auto-generated from config.yml.local\n# DO NOT EDIT THIS FILE DIRECTLY\n# Update config.yml.local and re-run start-all.sh instead\n\n"""


def load_yaml(path: Path) -> Dict[str, Any]:
    if not path.exists():
        raise FileNotFoundError(f"Configuration file '{path}' not found. Copy config.yml to {path} and update it.")
    with path.open() as fh:
        return yaml.safe_load(fh) or {}


def load_existing_env(path: Path) -> Dict[str, str]:
    values: Dict[str, str] = {}
    if not path.exists():
        return values
    with path.open() as fh:
        for raw_line in fh:
            line = raw_line.strip()
            if not line or line.startswith("#") or "=" not in line:
                continue
            key, value = line.split("=", 1)
            values[key.strip()] = value.strip()
    return values


def format_bool(value: Any) -> str:
    return str(bool(value)).upper()


def ensure_secret(value: str | None, fallback_key: str, existing_env: Dict[str, str], length: int = 48) -> str:
    if value and not value.lower().startswith("change-this") and not value.lower().startswith("generate-a"):  # user provided
        return value
    if existing_env.get(fallback_key):
        return existing_env[fallback_key]
    return secrets.token_urlsafe(length)


def add_if_present(env_lines: list[str], key: str, value: Any) -> None:
    if value is None or value == "":
        return
    env_lines.append(f"{key}={value}")


def build_env_lines(config: Dict[str, Any], existing_env: Dict[str, str]) -> list[str]:
    env_lines: list[str] = []

    providers = config.get("ai_providers", {})
    provider_mappings = {
        "openai": ("OPENAI_API_KEY",),
        "anthropic": ("ANTHROPIC_API_KEY",),
        "gemini": ("GEMINI_API_KEY",),
        "mistral": ("MISTRAL_API_KEY",),
        "deepseek": ("DEEPSEEK_API_KEY", "DEEPSEEK_API_BASE"),
        "openrouter": ("OPENROUTER_API_KEY", "OPENROUTER_API_BASE"),
        "ollama": ("OLLAMA_API_BASE",),
        "lm_studio": ("LM_STUDIO_API_BASE",),
        "groq": ("GROQ_API_KEY",),
    }

    for provider, keys in provider_mappings.items():
        provider_cfg = providers.get(provider, {}) or {}
        enabled = provider_cfg.get("enabled", False)
        for idx, env_key in enumerate(keys):
            if env_key.endswith("_API_BASE"):
                value = provider_cfg.get("api_base")
            else:
                value = provider_cfg.get("api_key")
            # Always include API base if present even when provider disabled (useful for local endpoints)
            if env_key.endswith("_API_BASE") and value:
                add_if_present(env_lines, env_key, value)
            elif enabled and value:
                add_if_present(env_lines, env_key, value)
            elif enabled and env_key.endswith("_API_KEY") and not value:
                # Empty but required -> write blank to make missing obvious
                env_lines.append(f"{env_key}=")

    # Embeddings
    embedding_cfg = config.get("embedding", {}) or {}
    add_if_present(env_lines, "EMBEDDING_PROVIDER", embedding_cfg.get("provider"))
    add_if_present(env_lines, "EMBEDDING_MODEL", embedding_cfg.get("model"))
    embedding_api_key = embedding_cfg.get("api_key")
    if not embedding_api_key:
        provider_name = embedding_cfg.get("provider")
        provider_data = providers.get(provider_name, {}) if provider_name else {}
        if provider_data.get("enabled"):
            embedding_api_key = provider_data.get("api_key")
    add_if_present(env_lines, "EMBEDDING_API_KEY", embedding_api_key)

    # Backend AI defaults
    backend_ai = config.get("backend_ai_model", {}) or {}
    add_if_present(env_lines, "BACKEND_AI_PROVIDER", backend_ai.get("ai_provider"))
    add_if_present(env_lines, "BACKEND_AI_MODEL", backend_ai.get("ai_model"))

    # Optional providers (exposed even if disabled so users can flip them manually later)
    optional_keys = [
        "MISTRAL_API_KEY",
        "DEEPSEEK_API_KEY",
        "DEEPSEEK_API_BASE",
        "OPENROUTER_API_KEY",
        "OPENROUTER_API_BASE",
        "GROQ_API_KEY",
        "OLLAMA_API_BASE",
        "LM_STUDIO_API_BASE",
    ]
    present_keys = {line.split("=", 1)[0] for line in env_lines}
    for key in optional_keys:
        if key not in present_keys and key in existing_env:
            add_if_present(env_lines, key, existing_env[key])

    # Monitoring
    monitoring_cfg = config.get("monitoring", {}) or {}
    if monitoring_cfg.get("enabled", True):
        add_if_present(env_lines, "LOGFIRE_TOKEN", monitoring_cfg.get("logfire_token", ""))
    else:
        env_lines.append("LOGFIRE_TOKEN=")

    # Runtime flags
    runtime_cfg = config.get("runtime", {}) or {}
    debug_value = runtime_cfg.get("debug", False)
    env_lines.append(f"DEBUG={format_bool(debug_value)}")
    backend_level = (runtime_cfg.get("backend_log_level") or "INFO").upper()
    frontend_level = (runtime_cfg.get("frontend_log_level") or "INFO").upper()
    env_lines.append(f"BACKEND_LOGGING_LEVEL={backend_level}")
    env_lines.append(f"FRONTEND_LOGGING_LEVEL={frontend_level}")
    env_lines.append(f"LOGGING_LEVEL={backend_level}")

    # Local configuration
    local_cfg = config.get("local", {}) or {}
    ports_cfg = local_cfg.get("ports", {}) or {}
    def local_port(name: str, default: int) -> int:
        return int(ports_cfg.get(name, default))

    frontend_port = local_port('frontend', 3200)
    backend_port = local_port('backend', 8200)
    sql_generator_port = local_port('sql_generator', 8180)
    mermaid_port = local_port('mermaid_service', 8003)
    qdrant_port = local_port('qdrant', 6334)

    env_lines.append(f"FRONTEND_PORT={frontend_port}")
    env_lines.append(f"BACKEND_PORT={backend_port}")
    env_lines.append(f"SQL_GENERATOR_PORT={sql_generator_port}")
    env_lines.append(f"MERMAID_SERVICE_PORT={mermaid_port}")
    env_lines.append(f"QDRANT_PORT={qdrant_port}")

    urls_cfg = local_cfg.get("urls", {}) or {}
    add_if_present(env_lines, "MERMAID_SERVICE_URL", urls_cfg.get("mermaid_service", f"http://localhost:{mermaid_port}"))

    django_api_url = urls_cfg.get("django_api") or f"http://localhost:{backend_port}"
    qdrant_url = urls_cfg.get("qdrant") or f"http://localhost:{qdrant_port}"

    env_lines.append(f"DJANGO_API_URL={django_api_url}")
    env_lines.append(f"QDRANT_URL={qdrant_url}")

    paths_cfg = local_cfg.get("paths", {}) or {}
    add_if_present(env_lines, "EXPORTS_DIR", paths_cfg.get("exports_dir", "./exports"))
    add_if_present(env_lines, "LOGS_DIR", paths_cfg.get("logs_dir", "./logs"))
    add_if_present(env_lines, "DB_ROOT_PATH", paths_cfg.get("db_root_path", "./data"))
    add_if_present(env_lines, "DB_NAME_LOCAL", paths_cfg.get("db_name", "db.sqlite3"))

    options_cfg = local_cfg.get("options", {}) or {}
    env_lines.append(f"SQLGEN_BYPASS_EVALUATION={format_bool(options_cfg.get('sqlgen_bypass_evaluation', False))}")
    env_lines.append(f"RELEVANCE_LOG_JSONL={format_bool(options_cfg.get('relevance_log_jsonl', True))}")

    # RelevanceGuard thresholds
    rg_cfg = config.get("relevance_guard", {}) or {}
    add_if_present(env_lines, "RELEVANCE_STRICT_MIN_SCORE", rg_cfg.get("strict_min_score"))
    add_if_present(env_lines, "RELEVANCE_WEAK_MIN_SCORE", rg_cfg.get("weak_min_score"))
    add_if_present(env_lines, "RELEVANCE_DROP_BELOW", rg_cfg.get("drop_below"))
    add_if_present(env_lines, "RELEVANCE_W_BM25", rg_cfg.get("w_bm25"))
    add_if_present(env_lines, "RELEVANCE_W_STRUCT", rg_cfg.get("w_struct"))
    env_lines.append(f"RELEVANCE_USE_RRF={format_bool(rg_cfg.get('use_rrf', False))}")
    add_if_present(env_lines, "STRICT_FAILS_REQUIRED", rg_cfg.get("strict_fails_required"))

    # Secrets handling
    security_cfg = local_cfg.get("security", {}) or {}
    secret_key = ensure_secret(security_cfg.get("secret_key"), "SECRET_KEY", existing_env)
    nextauth_secret = ensure_secret(security_cfg.get("nextauth_secret"), "NEXTAUTH_SECRET", existing_env)
    django_api_key = ensure_secret(security_cfg.get("django_api_key"), "DJANGO_API_KEY", existing_env, length=32)

    env_lines.append(f"SECRET_KEY={secret_key}")
    env_lines.append(f"NEXTAUTH_SECRET={nextauth_secret}")
    env_lines.append(f"DJANGO_API_KEY={django_api_key}")

    # Misc flags
    env_lines.append("DOCKER_CONTAINER=false")

    return env_lines


def write_env(path: Path, lines: list[str]) -> None:
    path.parent.mkdir(parents=True, exist_ok=True)
    with path.open("w") as fh:
        fh.write(HEADER)
        fh.write("\n".join(lines))
        fh.write("\n")


def backup_existing(path: Path) -> None:
    if not path.exists():
        return
    backup_path = path.with_name(path.name + BACKUP_SUFFIX)
    try:
        if backup_path.exists():
            backup_path.unlink()
        path.replace(backup_path)
        print(f"Existing {path.name} backed up to {backup_path.name}")
    except OSError as exc:
        print(f"Warning: failed to backup {path}: {exc}", file=sys.stderr)


def main() -> int:
    parser = argparse.ArgumentParser(description="Generate .env.local from config.yml.local")
    parser.add_argument("--no-backup", action="store_true", help="Do not backup existing .env.local before regenerating")
    args = parser.parse_args()

    config = load_yaml(CONFIG_PATH)
    existing_env = load_existing_env(ENV_PATH)

    if not args.no_backup and ENV_PATH.exists():
        backup_existing(ENV_PATH)

    env_lines = build_env_lines(config, existing_env)
    write_env(ENV_PATH, env_lines)
    print(".env.local generated successfully")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
