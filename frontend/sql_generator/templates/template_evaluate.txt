** Here is the question, database type, database schema, directives, candidate sql, and the unit tests to evaluate the responses: **

**Question**
{QUESTION}

---
**Database type**
{DATABASE_TYPE}

---
**Schema**
{DATABASE_SCHEMA}

---
**Directives**
{DIRECTIVES}

---
**Evidence**
{EVIDENCE}

*** Candidate SQL Queries: ***
{CANDIDATE_SQL}

*** Unit Tests: ***
{UNIT_TESTS}

*** Test Generation Thinking: ***
{TEST_THINKING}

*** Gold SQL Examples (Reference Only - Do NOT Evaluate These): ***
{GOLD_SQL_EXAMPLES}

You are a professional SQL evaluator tasked with testing SQL queries against unit tests.

Your task is to:
1. Read the test units and all the information (question, database type and schema, directives, evidence and candidate SQLs)
2. Review the test generation thinking to understand the rationale behind the tests
3. Use the Gold SQL examples as reference to understand expected query patterns (these are NOT for evaluation)
4. Analyze each candidate SQL query
5. Apply EVERY test to EVERY candidate SQL individually
6. Evaluate each test-SQL combination to determine if it passes (OK) or fails (KO)

For your thinking field:
- Provide detailed step-by-step reasoning about how you evaluate each candidate SQL against each individual test criteria


For your answers field:
Provide a LIST of strings - one string for each candidate SQL.
You MUST evaluate ALL SQL candidates and provide exactly as many answer strings as there are SQL candidates.

Each string in the list must be formatted as:
"SQL #{number}: {test_result_list}"

Where test_result_list is a comma-separated list of test results in the format:
- "OK" if the SQL passes that specific test
- "KO - {reason}" if the SQL fails that specific test (provide a brief explanation)

Example answers list for 2 SQL candidates with 3 tests each:
[
  "SQL #1: OK, OK, KO - missing WHERE clause for charter schools",
  "SQL #2: OK, KO - incorrect join condition, OK"
]

CRITICAL: You MUST provide exactly as many answer strings as there are SQL candidates - one string for each SQL.

IMPORTANT: 
- You must evaluate EACH test against EACH SQL individually and report the result for every test-SQL combination
- **NEVER** mark a test as failed just because the query only addresses a part of the question
- Your role is ONLY to evaluate - the best SQL will be automatically selected based on test pass rates
- Do NOT make any selection or recommendation about which SQL is best
